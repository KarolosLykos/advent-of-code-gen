package cmd

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/dolmen-go/codegen"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"

	"github.com/KarolosLykos/advent-of-code-gen/internal/config"
)

var (
	yearFlag int
	dayFlag  int
)

const solutionTemplate = `// Code generated by aocgen; DO NOT EDIT.
package main

import (
	"bufio"
	"fmt"
	"os"
	"time"
)

func main() {
	start := time.Now()
	fmt.Println("Year: {{.Year}}| Day: {{.Day}}")
	input, err := parseInput("input.txt")
	if err != nil {
		panic(err)
	}

	fmt.Println("Part A: ", partA(input))
	fmt.Println("Part B: ", partB(input))
	fmt.Println("Finished: ", time.Since(start))
}

func partA(lines []string) any {
	return "not implemented"
}

func partB(lines []string) any {
	return "not implemented"
}

func parseInput(filename string) ([]string, error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}

	lines := make([]string, 0)

	s := bufio.NewScanner(f)
	for s.Scan() {
		lines = append(lines, s.Text())
	}

	return lines, nil
}

`

func NewGenCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "gen",
		Short: "Generate new puzzle",
		Long:  "Gen Generate a puzzle from year and day inputs",
		RunE:  genCmd,
	}

	cmd.Flags().IntVarP(&yearFlag, "year", "y", time.Now().Year(), "aoc gen [-y year]")
	cmd.Flags().IntVarP(&dayFlag, "day", "d", 1, "aoc init [-d day]")

	return cmd
}

func genCmd(cmd *cobra.Command, _ []string) error {
	if err := validateDates(); err != nil {
		return err
	}

	cfg, err := config.GetUserConfig()
	if err != nil {
		logrus.Error("could not get config file")
	}

	if _, err = os.Stat(cfg.ProjectDir); err != nil {
		return err
	}

	if err = cdToProject(cfg.ProjectDir); err != nil {
		logrus.Errorf("could not change directory: %v", err)

		return err
	}

	yearDir := cfg.ProjectDir + "/" + strconv.Itoa(yearFlag)
	if err = os.Mkdir(yearDir, 0o750); err != nil && !errors.Is(err, os.ErrExist) {
		logrus.Errorf("error creating directory: %v", err)

		return err
	}

	dayDir := yearDir + "/" + formatDay(dayFlag)
	if err = os.Mkdir(dayDir, 0o750); err != nil && !errors.Is(err, os.ErrExist) {
		logrus.Errorf("error creating directory: %v", err)

		return err
	}

	if err = createMainFile(dayDir, yearFlag, dayFlag); err != nil {
		logrus.Error(err)

		return err
	}

	inputFile, err := getInputFile(cmd.Context(), cfg.Session, yearFlag, dayFlag)
	if err != nil {
		logrus.Errorf("could not get input file %d/%d", yearFlag, dayFlag)

		return err
	}

	f, err := os.Create(dayDir + "/input.txt")
	if err != nil {
		logrus.Error(err)
		return err
	}

	if _, err = f.WriteString(inputFile); err != nil {
		return err
	}

	return nil
}

// validateDates validates years and days and setting default day.
func validateDates() error {
	if yearFlag <= 2020 || yearFlag > 2030 {
		return fmt.Errorf("invalid year")
	}

	if dayFlag < 1 || dayFlag > 31 {
		return fmt.Errorf("invalid day")
	}

	if time.Now().Month() != time.December {
		dayFlag = 1
	}

	return nil
}

// formatDay zero pads single-digit days.
func formatDay(day int) string {
	yearStr := strconv.Itoa(day)
	if len(yearStr) == 1 {
		return "0" + yearStr
	}
	return yearStr
}

func createMainFile(dayDir string, yearFlag, dayFlag int) error {
	_, err := os.Stat(dayDir + "/main.go")
	if err == nil && !errors.Is(err, os.ErrNotExist) {
		logrus.Infof("solution exists")

		return nil
	}

	tmpl := codegen.MustParse(solutionTemplate)

	return tmpl.CreateFile(dayDir+"/main.go", map[string]interface{}{"Year": yearFlag, "Day": formatDay(dayFlag)})
}

func getInputFile(ctx context.Context, session string, year, day int) (string, error) {
	url := fmt.Sprintf("https://adventofcode.com/%d/day/%d/input", year, day)
	c := http.Client{Timeout: 3 * time.Second}

	cookie := &http.Cookie{Name: "session", Value: session, MaxAge: 0}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return "", err
	}

	req.AddCookie(cookie)
	req.Header.Set("User-Agent", "github.com/KarolosLykos/advent-of-code-gen by Karolos Lykos")

	resp, err := c.Do(req)
	if err != nil {
		return "", err
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("something went wrong %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(body), nil
}
